{"version":3,"sources":["../6bb7d34435ba26787af2.worker.js","../webpack/bootstrap 6bb7d34435ba26787af2","libs/Solver.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","self","onmessage","e","data","moves","length","solvePuzzlePattern","solvePuzzleFringe","postMessage","cmd","solution","startSequence","allMoves","curArrayState","slice","concat","a","reconstructFromMoves","aArr","b","bArr","cArr","pattern","indexOf","start","toString","fringe","listCache","found","size","Math","sqrt","flimit","getHeuristics","fmin","Infinity","_loop2","_ret","_i2","fringeNode","g","parent","fringeArr","convertToNumArray","f","min","getMisplaced","nextStep","nextArr","move","unshift","expandNode","forEach","child","childG","index","splice","console","log","sequence","constructed","moveIndex","blankIndex","tempA","node","nodeArr","parentArr","possibleMoves","getAllMoves","blankParentIndex","childStrings","arr","newSequence","temp","temp2","Number","manhattan","getGridCoordinates","y","floor","x","getIndexByCoordinates","set","misplaced","cost","item","indexCoor","targetCoor","xMoves","abs","yMoves","str","split","blank","blankCoord","left","push","right","t"],"mappings":"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","file":"6bb7d34435ba26787af2.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nself.onmessage=function(e){if(e.data[\"cmd\"]===\"solve\"){var s=e.data[\"sequence\"];var moves=s.length>10?solvePuzzlePattern(s):solvePuzzleFringe(s);self.postMessage({cmd:\"solved\",solution:moves});}};var solvePuzzlePattern=function solvePuzzlePattern(startSequence){var allMoves=[];var moves=null;var curArrayState=startSequence.slice(0);moves=solvePuzzleFringe(curArrayState,[1,2,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var a=reconstructFromMoves(moves,startSequence);var aArr=a.slice(0);moves=solvePuzzleFringe(aArr,[1,2,3,4,\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var b=reconstructFromMoves(moves,a);var bArr=b.slice(0);moves=solvePuzzleFringe(bArr,[1,2,3,4,5,\"x\",\"x\",\"x\",9,\"x\",\"x\",\"x\",13,\"x\",\"x\",\"x\"]);allMoves=allMoves.concat(moves);var c=reconstructFromMoves(moves,b);var cArr=c.slice(0);moves=solvePuzzleFringe(cArr,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\"x\"]);allMoves=allMoves.concat(moves);return allMoves;};var solvePuzzleFringe=function solvePuzzleFringe(startSequence,pattern){//if there's a pattern, replace not used index in array with \"x\"\nif(pattern){var i=0;while(i<pattern.length-1){if(pattern[i]===\"x\")startSequence[startSequence.indexOf(i+1)]=\"x\";if(pattern[i]===\"o\")startSequence[startSequence.indexOf(i+1)]=\"o\";i++;}}var start=startSequence.toString();var fringe=[start];var listCache={};var found=false;var size=Math.sqrt(startSequence.length);var cost=1;var flimit=getHeuristics(startSequence,size);listCache[start]=[0,null];var moves=[];while(fringe.length>0&&!found){var fmin=Infinity;var _loop=function _loop(_i2){var fringeNode=fringe[_i2];var g=listCache[fringeNode][0];var parent=listCache[fringeNode][1];var fringeArr=convertToNumArray(fringeNode);var f=g+getHeuristics(fringeArr,size);if(f>flimit){fmin=Math.min(f,fmin);return\"continue\";}if(getMisplaced(fringeArr)===0){//construct path back with lookup of parents stored in cache\nvar nextStep=fringeNode;while(nextStep){//move is number switched with blank (last num) between current and parent sequence\nvar nextArr=convertToNumArray(nextStep);var move=nextArr.indexOf(nextArr.length);nextStep=listCache[nextStep][1];if(nextStep)moves.unshift(move);}found=true;return\"break\";}var childNodes=expandNode(fringeNode,parent,size,pattern);//console.log(\"children: \" + childNodes);\nchildNodes.forEach(function(child){var childG=g+cost;if(listCache[child]){var cachedG=listCache[child][0];if(cachedG<=childG)return;}var index=fringe.indexOf(child);if(index!==-1){fringe.splice(index,1);if(index<=_i2)_i2--;}fringe.splice(_i2+1,0,child);listCache[child]=[childG,fringeNode];});fringe.splice(_i2,1);_i2--;_i=_i2;};_loop2:for(var _i=0;_i<fringe.length;_i++){var _ret=_loop(_i);switch(_ret){case\"continue\":continue;case\"break\":break _loop2;}}flimit=fmin;if(fringe.length===0)console.log(\"not found\");}return moves;};var reconstructFromMoves=function reconstructFromMoves(moves,sequence){var constructed=sequence;var i=0;while(i<moves.length){var moveIndex=moves[i];var blankIndex=constructed.indexOf(constructed.length);var tempA=constructed[moveIndex];constructed[moveIndex]=constructed.length;constructed[blankIndex]=tempA;i++;}return constructed;};var expandNode=function expandNode(node,parent,size,pattern){var nodeArr=convertToNumArray(node);var parentArr=parent?convertToNumArray(parent):null;//start node has no parent\nvar possibleMoves=getAllMoves(nodeArr,size);var blankParentIndex=!parent||!parentArr?null:parentArr.indexOf(parentArr.length);var childStrings=[];var blankIndex=nodeArr.indexOf(nodeArr.length);possibleMoves.forEach(function(move,index,arr){//const moveIndex = possibleMoves[i];\nif(move!==blankParentIndex){var newSequence=nodeArr.slice(0);var temp=newSequence[blankIndex];var temp2=nodeArr[move]===\"x\"?nodeArr[move]:Number(nodeArr[move]);newSequence[blankIndex]=temp2;newSequence[move]=temp;var s=newSequence.toString();childStrings.unshift(s);}});//childStrings = shuffleArray(childStrings);\nreturn childStrings;};var getHeuristics=function getHeuristics(sequence,size){return manhattan(sequence,size);};var getGridCoordinates=function getGridCoordinates(index,size){var y=Math.floor(index/size);var x=index-y*size;return{x:x,y:y};};var getIndexByCoordinates=function getIndexByCoordinates(x,y,size){return y*size+x;};var getMisplaced=function getMisplaced(set){var misplaced=0;var i=0;while(i<set.length){if(set[i]!==\"x\"&&set[i]!==i+1&&set[i]!==set.length)misplaced++;i++;}return misplaced;};var manhattan=function manhattan(set,size){var cost=0;set.forEach(function(item,index,arr){//get grid position of current index\nif(item===arr.length){//don't factor in last number used for blank\n}else{if(item===\"x\"){}else{var indexCoor=getGridCoordinates(index,size);var targetCoor=getGridCoordinates(item-1,size);var xMoves=Math.abs(indexCoor.x-targetCoor.x);var yMoves=Math.abs(indexCoor.y-targetCoor.y);cost+=xMoves+yMoves;}}});return cost;};//to convert split string into array of numbers, (instead of strings as str.split('') does)\nvar convertToNumArray=function convertToNumArray(str){var arr=str.split(\",\");var i=0;while(i<arr.length){if(arr[i]!==\"x\")arr[i]=Number(arr[i]);i++;}return arr;};var getAllMoves=function getAllMoves(sequence,size){var moves=[];var blank=sequence.indexOf(sequence.length);var blankCoord=getGridCoordinates(blank,size);if(blankCoord.x>0){var left=getIndexByCoordinates(blankCoord.x-1,blankCoord.y,size);moves.push(left);}if(blankCoord.x<size-1){var right=getIndexByCoordinates(blankCoord.x+1,blankCoord.y,size);moves.push(right);}if(blankCoord.y>0){var t=getIndexByCoordinates(blankCoord.x,blankCoord.y-1,size);moves.push(t);}if(blankCoord.y<size-1){var b=getIndexByCoordinates(blankCoord.x,blankCoord.y+1,size);moves.push(b);}return moves;};\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 6bb7d34435ba26787af2.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6bb7d34435ba26787af2","self.onmessage = (e) => {\n  if (e.data[\"cmd\"] === \"solve\") {\n    let s = e.data[\"sequence\"];\n    let moves = s.length > 10 ? solvePuzzlePattern(s) : solvePuzzleFringe(s);\n    self.postMessage({ cmd: \"solved\", solution: moves });\n  }\n};\n\nconst solvePuzzlePattern = (startSequence) => {\n  let allMoves = [];\n  let moves = null;\n  let curArrayState = startSequence.slice(0);\n  moves = solvePuzzleFringe(curArrayState, [\n    1,\n    2,\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n  ]);\n  allMoves = allMoves.concat(moves);\n  const a = reconstructFromMoves(moves, startSequence);\n  const aArr = a.slice(0);\n  moves = solvePuzzleFringe(aArr, [\n    1,\n    2,\n    3,\n    4,\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n    \"x\",\n  ]);\n  allMoves = allMoves.concat(moves);\n  const b = reconstructFromMoves(moves, a);\n  const bArr = b.slice(0);\n  moves = solvePuzzleFringe(bArr, [\n    1,\n    2,\n    3,\n    4,\n    5,\n    \"x\",\n    \"x\",\n    \"x\",\n    9,\n    \"x\",\n    \"x\",\n    \"x\",\n    13,\n    \"x\",\n    \"x\",\n    \"x\",\n  ]);\n  allMoves = allMoves.concat(moves);\n  const c = reconstructFromMoves(moves, b);\n  const cArr = c.slice(0);\n  moves = solvePuzzleFringe(cArr, [\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    \"x\",\n  ]);\n  allMoves = allMoves.concat(moves);\n\n  return allMoves;\n};\n\nconst solvePuzzleFringe = (startSequence, pattern) => {\n  //if there's a pattern, replace not used index in array with \"x\"\n  if (pattern) {\n    let i = 0;\n    while (i < pattern.length - 1) {\n      if (pattern[i] === \"x\") startSequence[startSequence.indexOf(i + 1)] = \"x\";\n      if (pattern[i] === \"o\") startSequence[startSequence.indexOf(i + 1)] = \"o\";\n      i++;\n    }\n  }\n\n  let start = startSequence.toString();\n\n  const fringe = [start];\n  const listCache = {};\n\n  let found = false;\n  const size = Math.sqrt(startSequence.length);\n  const cost = 1;\n  let flimit = getHeuristics(startSequence, size);\n  listCache[start] = [0, null];\n  const moves = [];\n\n  while (fringe.length > 0 && !found) {\n    let fmin = Infinity;\n\n    for (let i = 0; i < fringe.length; i++) {\n      const fringeNode = fringe[i];\n      const g = listCache[fringeNode][0];\n      const parent = listCache[fringeNode][1];\n      const fringeArr = convertToNumArray(fringeNode);\n      const f = g + getHeuristics(fringeArr, size);\n\n      if (f > flimit) {\n        fmin = Math.min(f, fmin);\n        continue;\n      }\n\n      if (getMisplaced(fringeArr) === 0) {\n        //construct path back with lookup of parents stored in cache\n\n        let nextStep = fringeNode;\n        while (nextStep) {\n          //move is number switched with blank (last num) between current and parent sequence\n          const nextArr = convertToNumArray(nextStep);\n          const move = nextArr.indexOf(nextArr.length);\n          nextStep = listCache[nextStep][1];\n          if (nextStep) moves.unshift(move);\n        }\n\n        found = true;\n        break;\n      }\n\n      const childNodes = expandNode(fringeNode, parent, size, pattern);\n\n      //console.log(\"children: \" + childNodes);\n      childNodes.forEach((child) => {\n        const childG = g + cost;\n        if (listCache[child]) {\n          let cachedG = listCache[child][0];\n          if (cachedG <= childG) return;\n        }\n\n        const index = fringe.indexOf(child);\n        if (index !== -1) {\n          fringe.splice(index, 1);\n          if (index <= i) i--;\n        }\n\n        fringe.splice(i + 1, 0, child);\n        listCache[child] = [childG, fringeNode];\n      });\n\n      fringe.splice(i, 1);\n      i--;\n    }\n\n    flimit = fmin;\n\n    if (fringe.length === 0) console.log(\"not found\");\n  }\n\n  return moves;\n};\n\nconst reconstructFromMoves = (moves, sequence) => {\n  let constructed = sequence;\n  let i = 0;\n  while (i < moves.length) {\n    const moveIndex = moves[i];\n    const blankIndex = constructed.indexOf(constructed.length);\n    const tempA = constructed[moveIndex];\n    constructed[moveIndex] = constructed.length;\n    constructed[blankIndex] = tempA;\n\n    i++;\n  }\n\n  return constructed;\n};\n\nconst expandNode = (node, parent, size, pattern) => {\n  const nodeArr = convertToNumArray(node);\n  const parentArr = parent ? convertToNumArray(parent) : null; //start node has no parent\n  const possibleMoves = getAllMoves(nodeArr, size);\n  const blankParentIndex =\n    !parent || !parentArr ? null : parentArr.indexOf(parentArr.length);\n\n  let childStrings = [];\n  const blankIndex = nodeArr.indexOf(nodeArr.length);\n\n  possibleMoves.forEach((move, index, arr) => {\n    //const moveIndex = possibleMoves[i];\n\n    if (move !== blankParentIndex) {\n      const newSequence = nodeArr.slice(0);\n      const temp = newSequence[blankIndex];\n      const temp2 =\n        nodeArr[move] === \"x\" ? nodeArr[move] : Number(nodeArr[move]);\n      newSequence[blankIndex] = temp2;\n      newSequence[move] = temp;\n      const s = newSequence.toString();\n      childStrings.unshift(s);\n    }\n  });\n\n  //childStrings = shuffleArray(childStrings);\n  return childStrings;\n};\n\nconst getHeuristics = (sequence, size) => {\n  return manhattan(sequence, size);\n};\n\nconst getGridCoordinates = (index, size) => {\n  const y = Math.floor(index / size);\n  const x = index - y * size;\n\n  return { x: x, y: y };\n};\n\nconst getIndexByCoordinates = (x, y, size) => {\n  return y * size + x;\n};\n\nconst getMisplaced = (set) => {\n  let misplaced = 0;\n  let i = 0;\n  while (i < set.length) {\n    if (set[i] !== \"x\" && set[i] !== i + 1 && set[i] !== set.length)\n      misplaced++;\n    i++;\n  }\n\n  return misplaced;\n};\n\nconst manhattan = (set, size) => {\n  let cost = 0;\n\n  set.forEach((item, index, arr) => {\n    //get grid position of current index\n    if (item === arr.length) {\n      //don't factor in last number used for blank\n    } else {\n      if (item === \"x\") {\n      } else {\n        let indexCoor = getGridCoordinates(index, size);\n        let targetCoor = getGridCoordinates(item - 1, size);\n        let xMoves = Math.abs(indexCoor.x - targetCoor.x);\n        let yMoves = Math.abs(indexCoor.y - targetCoor.y);\n\n        cost += xMoves + yMoves;\n      }\n    }\n  });\n\n  return cost;\n};\n\n//to convert split string into array of numbers, (instead of strings as str.split('') does)\nconst convertToNumArray = (str) => {\n  const arr = str.split(\",\");\n  let i = 0;\n  while (i < arr.length) {\n    if (arr[i] !== \"x\") arr[i] = Number(arr[i]);\n    i++;\n  }\n\n  return arr;\n};\n\nconst getAllMoves = (sequence, size) => {\n  let moves = [];\n\n  const blank = sequence.indexOf(sequence.length);\n  const blankCoord = getGridCoordinates(blank, size);\n\n  if (blankCoord.x > 0) {\n    const left = getIndexByCoordinates(blankCoord.x - 1, blankCoord.y, size);\n    moves.push(left);\n  }\n\n  if (blankCoord.x < size - 1) {\n    const right = getIndexByCoordinates(blankCoord.x + 1, blankCoord.y, size);\n    moves.push(right);\n  }\n\n  if (blankCoord.y > 0) {\n    const t = getIndexByCoordinates(blankCoord.x, blankCoord.y - 1, size);\n    moves.push(t);\n  }\n\n  if (blankCoord.y < size - 1) {\n    const b = getIndexByCoordinates(blankCoord.x, blankCoord.y + 1, size);\n    moves.push(b);\n  }\n\n  return moves;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/Solver.worker.js"],"sourceRoot":""}